<h1># NLDB</h1>
<h1>Система поиска текстовой информации по шаблону в больших текстовых файлах</h1>
<h3>Проект создается как библиотека классов для использования в проектах обработки текстовой информации.

<dl>
<dt>Основной класс с функционалом системы: </dt>
  <dd>Language.</dd>
<dt>Основные модули: </dt>
  <dd>NLDB - программа (в перспективе библиотека класов) с основным функционалом; </dd>
  <dd>NLCLI - интерпретатор командной строки для создания, наполнения и управления хранилищем данных; </dd>
  <dd>NLDBTests - тесты.</dd>
</dt>
<dt>Платформа:</dt>
<dd>.NET Framework 4.5.2, использется SQLite 1.0.109</dd>
</dl>
</h3>

<h2>Назначение системы</h2>
<h4>Эксперименты с алгоритмами обработки текста на естественноых и искусственных языках</h4>
<h2>Функционал системы</h2>
<b>  
<p>Построение иерархической структуры текста для анализа.</p>
<p>Поиск нужного блока текста с использованием различных метрик схожести.</p>
<p>Поиск связанных блоков текста, где связь определяется различными отношениями: следования, предшествования, включения и т.п.</p>
</b>

<h3>Описание и реализация задач в системе</h3>
<ol>
<li>Построение иерархической многоуровневой структуры текста путем создания Словаря (метод Language.BuildLexicon), состоящего из ранжированных Слов (класс Word).</li>
  <ol>
    <li>Исходный текст является линейной последовательностью символов и подается на вход как текстовый файл (UTF-8) или строка System.String. При помощи простого лексического анализа текст разбивается на слова ранга n (свойство Word.rank), где n - это максимальный ранг слов, заданный в настройках системы. 
<b>Пример.</b> Предположим, текст является файлом с набором статей Wikipedia. Лексический анализ разбивает текст на статьи - Слова ранга 3, которые, в свою очередь разбиваются на Слова ранга 2 - предложения, которые разбиваются на Слова ранга 1 - Слова, которые состоят из букв - Слов ранга 0.
    </li>
    <li>На данный момент (8.10.2018) лексический анализатор (класс Parser) приводит текст весь текст к нижнему регистру, удаляет незначимые символы, разделяет текст на фрагменты в соответствии с символами-разделителями, заданными регулярными выражениями (метод Parser.Split).
    </li>
  </ol>
  <ol>
    <li>
      Каждое Слово ранга n имеет следующие представления:
    <ul>
      <li>Блок текста, ограниченный символами разделителями;</li>
      <li>Дерево Слов. Высота дерева - n, потомки корня дерева - Слова ранга n-1;</li>
    </ul>
    </li>
    <li>
Словарь объединяет в себе слова различных рангов. Для достижения эффективности обработки данных возможно разбиение Словаря на несколько, содержащих Слова только одного ранга.
    </li>
  </ol>
</li>
<li>
  Поиск блока текста с использованием различных метрик схожести.
  <ol>
    <li>
      Поиск Слова из Словаря по введенной строке (метод Language.Identify) производится как поиск Слова, для которого оценка уверенности (confidence) в похожести на введенный текст максимальна.
    </li>
    <li>
      По введенной строке строится Слово, начиная с составляющих минимального 0-го ранга (например, букв). Построенные Слова сравнивается со Словами из Словаря, для каждого из которых вычисляется оценка схожести. Ближайшим считается Слово с максимальной оценкой схожести.
    </li>
    <li>Метрики для вычисления схожести могут различаться для разных рангов. На данные момент используются метрики: Confidence.Equality,
Confidence.Cosine, Confidence.SoftInclusive (пояснения и формулы в тексте класса Confidence).</li>
    <li>Уверенность в схожести Слова определяется по формуле, аналогичной формуле полной вероятности (по формуле Байеса), исходя из следующих предпосылок: Если Слово ранга n состоит из некоторых Слов ранга n-1, то полная апостериорная уверенность того что строка является Словом ранга n, является суммой произведений уверенностей в схожести соответстветствующих составляющих термов ранга n-1.</li>
  </ol>
</li>
<li>Добавлен метод для поиска набора похожих на введенный текст Слов (метод Language.Similars).</li>
<li>Добавлен метод для получения следующего за найденным "похожим" на введенный текст Словом (метод Language.Next). Предполагается использование в диалоговых системах машинного интерфейса.</li>
<li>Добавлен метод рекуррентной последовательности слов, следующих за "похожим" на введенный текст (метод Language.PredictRecurrent). На данный момент (01.09.2018) закомментирован, так как выводит связный бред и не представляет интереса, кроме развлекательных целей</li>
<li>Добавлен метод для выделения синтаксического ядра Слов высоких рангов (например, суть статьи в нескольких предложениях) (метод Language.GetCore). Алгоритм активно использует матрицу схожестви между Словами, минимаксные стратегии оптимизации и методы перечисленные выше. Требует напильника, а может и топора.</li>
</ol>
